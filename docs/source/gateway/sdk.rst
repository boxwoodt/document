SDK 说明
=======================

在 RT-Thread 嵌入式操作系统的强大基础上，TKB-320 SDK 不仅成功地适配了多种关键组件，如LAN8720A以太网芯片、NT26E CAT1 模块和 TurMass 无线模块，还在此基础上实现了高效、稳定的网关功能。这一功能的实现，为客户在开发 TurMass 网关时提供了极大的便利与灵活性。

通过该SDK，用户能够轻松地将多种设备连接到单一的网络平台。这意味着，无论是在家庭自动化、工业物联网，还是智慧城市建设中，使用者都能将不同品牌、不同类型的设备集成在一个系统之中。例如，用户可以将温湿度传感器、智能摄像头和无线开关等多个设备通过TurMass网关进行管理与控制，实现更加智能和高效的应用场景。

目录介绍
++++++++++++++++++++++++++++++++++

.. code-block::

    ├─bsp
    │  └─stm32   
    │      ├─libraries     
    │      │  ├─HAL_Drivers            // RT-Thread 设备驱动
    │      │  └─STM32H7xx_HAL          // STM32 HAL库
    │      ├─stm32h750
    │      │  ├─applications
    │      │  │  ├─env_cfg             // 环境变量保存
    │      │  │  ├─misc                // 杂项，如LED、按键、看门狗等
    │      │  │  └─protocol            // 协议解析及封装
    │      │  ├─at_server              // AT指令
    │      │  ├─board                  // 开发板硬件
    │      │  ├─packages               // 软件包
    │      │  └─turmass
    │      │      ├─cmd                // 无线模块msh指令
    │      │      ├─example            // LAN示例代码
    │      │      │  ├─lan_async       // 异步组网示例
    │      │      │  ├─lan_high        // 高并发组网示例
    │      │      │  └─lan_sync        // 同步组网示例
    │      │      ├─slip               // 无线模块驱动
    │      │      └─upgrade            // 无线模块升级
    │      └─tools
    ├─components                       // 系统组件
    ├─include                          // RT-Thread 头文件
    ├─libcpu                           // 芯片架构适配
    ├─src                              // RT-Thread 内核源码
    └─tools

网关功能
++++++++++++++++++++++++++++++++++

网关具有以下功能，：

.. csv-table:: 网关功能表
    :header: "序号", "功能", "状态"
    :widths: 10 40 20

    "1",  "`TurMass 模块驱动`_", "已完成"
    "2",  "`TurMass 模块升级`_", "已完成"
    "3",  "`以太网联网`_",       "已完成"
    "4",  "`CAT1 联网`_",        "已完成"
    "5",  "`数据上下行`_",       "已完成"
    "6",  "`本地升级 MCU`_",     "已完成"
    "7",  "`远程升级 MCU`_",     "已完成"
    "8",  "`shell 命令`_",       "已完成"
    "9",  "`远程管理`_",         "已完成"
    "10", "`参数保存`_",         "已完成"

TurMass 模块驱动
------------------------------------------------------

TKB-320 与无线模块间采用 SLIP 协议通讯。目前该协议在网关示例工程中已实现，对外接口函数为网关 API 函数。

驱动模块源码位置：bsp\\stm32\\stm32h750\\turmass\\slip 。

TurMass 模块升级
------------------------------------------------------

网关开发板支持 TurMass 模块升级。网关开发板通过以太网将升级文件下载到 flash 中，然后通过升级协议烧录到 TurMass 模块中。

无线模块升级源码位置：bsp\\stm32\\stm32h750\\turmass\\upgrade 。

以太网联网
------------------------------------------------------

本网关使用 LAN8720A 与以太网连接。基于 RT-Thread 嵌入式操作系统，使用 LWIP 协议栈来实现网络传输。

CAT1 联网
------------------------------------------------------

本网关采用 NT26E 模块与互联网连接。网关开发板中使用 UART 接口，用于配置和查询 CAT1 模块参数，使用 USB 接口，用于连接云服务器。

采用 CherryUSB 来实现 RNDIS 主机。

数据上下行
------------------------------------------------------

| 消息信息通过 json 格式传输，详情可以参考 :ref:`gw_protocol-label` 。

| 源码位于： *bsp\\stm32\\stm32h750\\applications\\protocol\\protocol.c*

本地升级 MCU
------------------------------------------------------

| 网关本地升级通过 UART 口升级，通过 Ymodem 协议将升级固件传输到外部 Flash 保存。固件传输完成后，网关自动重启，重新进入 BOOT 状态，更新固件。

| 网关MCU升级流程可以参考：:ref:`gw320_upgrade-label`。

| 网关内部flash，大小为128KB，外部使用两个 flash，一个为 W25Q64，大小为8MB，用于存储执行代码，另一个为 W25Q128, 大小为16MB，用于存储固件和参数。

.. csv-table:: 网关 flash 分区表
    :header: "分区名", "位置", "起始地址", "分区长度"
    :widths: 30 30 20 20 

    "mus_image",    "外部flash", "0",       "512KB"
    "reserve",      "外部flash", "512KB",   "512KB"
    "download",     "外部flash", "1MB",     "2MB"
    "factory",      "外部flash", "3MB",     "2MB"
    "easyflash",    "外部flash", "5MB",     "1MB"
    "filesystem",   "外部flash", "8MB",     "8MB"

远程升级 MCU
------------------------------------------------------

参考通讯协议： :ref:`gw_protocol-label`

shell 命令
------------------------------------------------------

shell 为网关的对外接口，用户可以通过增加 shell 命令，便于调试和测试网关。

远程管理
------------------------------------------------------

参考通讯协议： :ref:`gw_protocol-label`

参数保存
------------------------------------------------------

在网关中，一些参数需要更改重启后仍然生效，如：IP地址、服务器地址、端口等。在网关 SDK 中，我们调用 easyflash 的接口函数，来保存和读取参数。最后保存在外部 flash 的 *easyflash* 分区，分区大小为 128KB 。

网关的参数保存和读取代码位置： `bsp\\stm32\\stm32h750\\applications\\env_cfg\\env_op.c` 。


